Функция ReadBinFile в исходном коде LongNumber.c дублирована. Изначально, закомментирован неоптимизированный код.

Измерение скорости представляется следующим образом - происходит чтение одного и того же файла несколько раз. После каждого чтения отображается время, затраченное на эту операцию. После чего, вручную комментируется исходная функция и раскомментируется неоптимизированная, операция повтяряется.

Для эксперимента проводится 20 вызовов функции чтения на каждую вариацию кода, после чего находится их среднее арифметическое. Эту величину и будем подразумевать как результат - время, за которое выполняется функция.

Время представляется в виде Хе+Y (пример: 7,67е+08). Коэффициент при е - количесво миллисекунд, затраченное на операцию (применимо при втором коэффициенте = 08), второй коэффициент - степень 10-ти.

В качестве прогоняемого файла используется LN_Class_wrap.cpp (167,1 кБ), сформированный после выполнения makefile.
-------------------------------------------------------------------------------------
!!!ВНИМАНИЕ!!!

Измерение происходит в ОС Linux Ubuntu x64 через Oracle VBox. Результаты эксперимента на других машинах иных конфигураций могут отличаться. 
-------------------------------------------------------------------------------------
Ниже приведены выдержки из терминала (логи) вызова функции с указанием времени чтения:

-для оптимизированного кода (см. PIC1):
>>> a.ReadBin("LN_Class_wrap.cpp")
1.144e+09
>>> a.ReadBin("LN_Class_wrap.cpp")
1.522e+09
>>> a.ReadBin("LN_Class_wrap.cpp")
8.82e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.79e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.92e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.35e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.45e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.86e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.19e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.88e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.11e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
1.249e+09
>>> a.ReadBin("LN_Class_wrap.cpp")
9.5e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.54e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.49e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
7.4e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
1.011e+09
>>> a.ReadBin("LN_Class_wrap.cpp")
8.88e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
7.4e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.24e+08


T_RES = 9.454e+08


-для неоптимизированного кода (см. PIC2):
>>> a.ReadBin("LN_Class_wrap.cpp")
9.4e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.56e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.95e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.21e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
1.669e+09
>>> a.ReadBin("LN_Class_wrap.cpp")
8.71e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.81e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.21e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.89e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.36e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.23e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.46e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.11e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
9.16e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
7.46e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.86e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.92e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.92e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.88e+08
>>> a.ReadBin("LN_Class_wrap.cpp")
8.87e+08

T_RES2 = 9.333e+08
 
-------------------------------------------------------------------------------------
Из результатов видно, что оптимизированный код таковым не является, т.к. время выполнения примерно равно, а в некоторых случаях (как и по среднему арифметическому) выше, чем при выполнении неоптимизированного кода. Для более точных измерений стоит провести эксперимент на нескольких машинах, не в гостевых ОС виртуальных машин, а также увеличив число прогонки.


